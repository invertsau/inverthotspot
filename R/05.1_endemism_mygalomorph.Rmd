---
title: "Endemism analysis"
author: "Fonti Kar, Payal Bal, Aaron Greenfield"
date: "2023-12-16"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

pacman::p_load(arrow, here, phyloregion, terra, sf, sp, tidyverse, ggplot2, ozmaps, tmap, viridis, spdep, purrr, gstat, raster)

source("R/utils.R")
```

### Load in data
```{r}
myg_spiders_cleaned <- read_parquet(get_latest_cleaned_data(path_to_clean_data = paste0(here("output/data/"), "/"))[2])

myg_spiders_expert <- read_parquet(get_latest_cleaned_data(path_to_clean_data = paste0(here("output/data/"), "/"))[1]) 
```


### Load alpha hull spatial polygons

This is a massive list, each element is a spatial polygon dataframe

```{r}
species_polys_points <- readRDS("output/spatial/Spatial_alpha_hulls_sf_class_cleaned_Mygalomorphae_withassertions_2025-08-14_ALA.rds")

species_polys_points_expert <- readRDS("output/spatial/Spatial_alpha_hulls_sf_class_expert_cleaned_expert_recordsMygalomorphae_withassertions_2025-08-14_ALA.rds")
```

## ALL DATA

### Pre-processing

```{r}
# Extract POLYGONs from GEOMETRYCOLLECTIONs
species_polys_clean <- species_polys_points |>
  st_collection_extract() |>
  group_by(species) |>
  summarise(geometry = st_union(conr_ahull_sf))
  
# Combine into one large spatial dataframe
combinedShp <- terra::vect(species_polys_clean)

#projecting to Albers Equal Area projection (EPSG:9473 (GDA2020 / Australian Albers))
combinedShp_equalarea <- project(combinedShp, "EPSG:9473") 


# now for point-only species
species_points_clean <- species_polys_points |>
  filter(st_geometry_type(conr_ahull_sf) %in% c("POINT", "MULTIPOINT")) |>
  rename(geometry = conr_ahull_sf) |>
  dplyr::select(-NAME)

## seems like phyloregion::polys2comm() also works for point data if in spatvector format
myg_spiders_cleaned_points <- myg_spiders_cleaned |>
  filter(scientificName %in% species_points_clean$species) |>
  dplyr::select(species, decimalLongitude, decimalLatitude) |>
  sf::st_as_sf(coords = c("decimalLongitude", "decimalLatitude"), crs = "EPSG:4326") |>
  sf::st_transform(crs = "EPSG:9473") #projecting to Albers Equal Area projection (EPSG:9473 (GDA2020 / Australian Albers))

combinedShp_points_equalarea <- terra::vect(myg_spiders_cleaned_points)

```

### Calculate Community Matrix

Convert raw input distribution data to community at 0.05 decimal degrees
`trace = 1` is passed to `mean_dist()` which generates mean pairwise distance matrix from a set many pairwise distance matrices. Note: all matrices should be of the same dimension. `trace` "traces" the function; trace = 2 or higher will be more voluminous

```{r}
# community matrix for species with alpha hulls (at least 3 records)
comm.poly <- phyloregion::polys2comm(dat = combinedShp_equalarea, trace=1, res = 5000)
# str(comm.poly)
# plot(comm.poly$map)

# community matrix for species without alpha hulls (<3 records)
comm.point <- phyloregion::polys2comm(dat = combinedShp_points_equalarea, trace = 1, res = 5000)


# combining
all_species <- union(colnames(comm.poly$comm_dat), colnames(comm.point$comm_dat))

missing_in_poly <- setdiff(all_species, colnames(comm.poly$comm_dat))
missing_in_poly_matrix <- sparseMatrix(i = numeric(0), j = numeric(0), x = numeric(0),
                                   dims = c(nrow(comm.poly$comm_dat), 
                                            length(missing_in_poly)))
colnames(missing_in_poly_matrix) <- missing_in_poly


missing_in_point <- setdiff(all_species, colnames(comm.point$comm_dat))
missing_in_point_matrix <- sparseMatrix(i = numeric(0), j = numeric(0), x = numeric(0),
                                   dims = c(nrow(comm.point$comm_dat), 
                                            length(missing_in_point)))
colnames(missing_in_point_matrix) <- missing_in_point


comm.poly_all_spp  <- cbind(comm.poly$comm_dat, missing_in_poly_matrix)
comm.point_all_spp  <- cbind(comm.point$comm_dat, missing_in_point_matrix)

# Expand both matrices to have all grid cells
all_grids <- union(rownames(comm.poly_all_spp), rownames(comm.point_all_spp))

expand_rows <- function(mat, all_grids) {
  missing <- setdiff(all_grids, rownames(mat))
  if (length(missing) > 0) {
    mat <- rbind(mat, Matrix(0, nrow=length(missing), ncol=ncol(mat),
                             dimnames=list(missing, colnames(mat))))
  }
  mat[all_grids, , drop=FALSE]  # reorder rows
}

comm.poly_all_spp_all_grids <- expand_rows(comm.poly_all_spp, all_grids)
comm.point_all_spp_all_grids <- expand_rows(comm.point_all_spp, all_grids)

# matching order of columns prior to combining matrices
species_order <- colnames(comm.poly_all_spp_all_grids)
comm.point_all_spp_all_grids <- comm.point_all_spp_all_grids[,species_order, drop = FALSE]

# Combine (sum values if grids overlap)
comm_merged <- comm.poly_all_spp_all_grids + comm.point_all_spp_all_grids

```

### Calculate weighted endemism 

```{r}
Endm.mygalomorph <- phyloregion::weighted_endemism(comm_merged)

# merging alpha hull- and point-based maps, ensuring that richness is summed in overlapping cells
comm_overlapping <- merge(comm.poly$map, comm.point$map, by = "grids", all.x = TRUE)
comm_overlapping$richness <- ifelse(is.na(comm_overlapping$richness.x), 0, comm_overlapping$richness.x) + ifelse(is.na(comm_overlapping$richness.y), 0, comm_overlapping$richness.y)

non_overlapping <- comm.point$map[which(!values(comm.point$map)[1]$grids %in% values(comm.poly$map)[1]$grids),]

comm_merged_map <- rbind(comm_overlapping, non_overlapping)

## Join endemism results back to spatial community data matrix
m1.poly_merged <- merge(comm_merged_map, data.frame(grids=names(Endm.mygalomorph), WE=Endm.mygalomorph), by="grids")

# Drop NA in WE
m1.poly <- m1.poly_merged[!is.na(m1.poly_merged$WE),]

m1.poly

```


### Calulate corrected weighted endemism

Weighted endemism tally per cell divided by the species richness of that cell

```{r}
m1.poly$corrected_endemism <- m1.poly$WE/m1.poly$richness
```

### Assigning hotspots based on percentile

```{r}
m1.poly$rich_perc <- m1.poly$richness > quantile(m1.poly$richness, probs = 0.95)
m1.poly$WE_perc <- m1.poly$WE > quantile(m1.poly$WE, probs = 0.95)
m1.poly$CWE_perc <- m1.poly$corrected_endemism > quantile(m1.poly$corrected_endemism, probs = 0.95)
```

### Create a endemism map

Convert to `sf` 

```{r}
crs(m1.poly) <- "EPSG:9473"

# projecting back to WGS84 for visualisation
m1_sf <- 
  sf::st_as_sf(m1.poly) |> 
  sf::st_transform(4326)

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_sf(data = m1_sf, aes(fill = WE), col = NA) + 
  geom_sf(data = subset(m1_sf, WE_perc), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_sf(data = m1_sf, aes(fill = corrected_endemism), col = NA) + 
  geom_sf(data = subset(m1_sf, CWE_perc), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155), 
           ylim = c(-10, -45)) + 
  viridis::scale_fill_viridis(option = "G",direction = -1) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_sf(data = m1_sf, aes(fill = richness), col = NA) + 
  geom_sf(data = subset(m1_sf, rich_perc), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155), 
           ylim = c(-10, -45)) + 
  viridis::scale_fill_viridis(option = "G",direction = -1) + 
  theme_minimal() +
  theme(legend.position = "bottom")

```

### Correcting for sampling bias

#### getting sampling rate and pop density values as rasters

```{r}
#reading output from sampbias package
bias_map <- readRDS("output/sampling_bias/samp_bias_map.rds")

#extracting estimated sampling rate data
sampling_rate <- bias_map$data |> 
  filter(split == "roads+cities+airports+waterbodies") |> 
  mutate(log_sr = log(val+1)) |>
  dplyr::select(-c(split, val))

# creating raster and projecting to equal area crs
sampling_rate_raster <- rast(sampling_rate)
crs(sampling_rate_raster) <- "EPSG:4326"
sampling_rate_raster_ea <- project(sampling_rate_raster, "EPSG:9473")

# loading in population density for the 2023-24 financial year (Australian Bureau of Statistics. (2023-24). Regional population. ABS. https://www.abs.gov.au/statistics/people/population/regional-population/2023-24.)
pop_density <- rast("data/sampling_bias/pop_density/apg24e_1_0_0.tif")
crs(pop_density) <- "EPSG:3577"
pop_density_ea <- project(pop_density, "EPSG:9473")
```

#### converting biodiversity metrics to raster to perform corrections

```{r}
# converting biodiversity metrics to raster to perform corrections
m1.poly_rast <- rast(m1.poly, res = 5000)
# transferring from m1.poly attributes into a SpatRaster with multiple layers
m1.poly_raster <- rast(lapply(names(m1.poly)[c(6,8,9)], function(att) {
  rasterize(m1.poly, m1.poly_rast, field = att)
}))
# setting crs
crs(m1.poly_raster) <- crs(sampling_rate_raster_ea)
```

#### estimating sampling bias

```{r}
# resampling sampling rate and pop density rasters to get them to match the extent and resolution of the biodiversity raster
sampling_rate_raster_ea_resample <- resample(sampling_rate_raster_ea, m1.poly_raster, method = "bilinear")

pop_density_aggregate <- terra::aggregate(pop_density_ea, fact = 5, fun = sum) # aggregating 1x1 km grid to a 5x5 km grid
pop_density_resample <- resample(pop_density_aggregate, m1.poly_raster, method = "bilinear")
log_pop_density_resample <- log(pop_density_resample+1)

#estimating influence of pop density via a gaussian smoothing kernel
# Parameters
sigma_km <- 50 # influence becomes near zero beyond 3*sigma
cellsize_km <- res(log_pop_density_resample)[1] / 1000  # convert cell size to km
sigma_cells <- sigma_km / cellsize_km
radius_cells <- 3*sigma_cells  # cutoff at 3σ
# Build Gaussian kernel matrix
xy <- expand.grid(-radius_cells:radius_cells, -radius_cells:radius_cells)
d <- sqrt(xy[,1]^2 + xy[,2]^2) # distance from the source (pythagorus)
w <- matrix(exp(-(d^2) / (2*sigma_cells^2)), # gaussian kernel formula
            nrow=2*radius_cells+1, byrow=FALSE)

# human access/sampling effort as decay from cells based on population
decay <- focal(log_pop_density_resample, w=w, fun="mean", na.policy="omit", na.rm = TRUE)
plot(decay)
names(decay) <- "pop_density_influence"

# standardising pop density effect
decay_mean <- global(decay, "mean", na.rm = TRUE)[1,1]
decay_sd <- global(decay, "sd", na.rm = TRUE)[1,1]
decay_std <- (decay - decay_mean)/decay_sd

#standardising sampling rate
sampling_rate_raster_ea_resample_mean <- global(sampling_rate_raster_ea_resample, "mean", na.rm = TRUE)[1,1]
sampling_rate_raster_ea_resample_sd <- global(sampling_rate_raster_ea_resample, "sd", na.rm = TRUE)[1,1]
sampling_rate_raster_ea_resample_std <- (sampling_rate_raster_ea_resample -
                                         sampling_rate_raster_ea_resample_mean)/sampling_rate_raster_ea_resample_sd

#combining the two bias sources
tot_samp_bias <- mean(decay_std, sampling_rate_raster_ea_resample_std)
names(tot_samp_bias) <- "total_sampling_bias"
plot(c(decay_std, sampling_rate_raster_ea_resample_std, tot_samp_bias))

# normalising to a range of 1-10
tot_samp_bias_min <- global(tot_samp_bias, "min", na.rm = TRUE)[1,1]
tot_samp_bias_max <- global(tot_samp_bias, "max", na.rm = TRUE)[1,1]
tot_samp_bias_norm <- ((tot_samp_bias - tot_samp_bias_min)/(tot_samp_bias_max - tot_samp_bias_min))*(10-1)+1 

```

#### adjusting biodiversity metrics based on sampling bias

```{r}
# adjusting biodiversity metrics based on sampling bias
WE_samp_bias <- terra::app(x = c(m1.poly_raster$WE, tot_samp_bias_norm), 
                           fun = function(x){return(x[1]/x[2])})
CWE_samp_bias <- terra::app(x = c(m1.poly_raster$corrected_endemism, tot_samp_bias_norm), 
                                 fun = function(x){return(x[1]/x[2])})
richness_samp_bias <- terra::app(x = c(m1.poly_raster$richness, tot_samp_bias_norm), 
                                 fun = function(x){return(x[1]/x[2])})

merged <- c(WE_samp_bias, CWE_samp_bias, richness_samp_bias)
names(merged) <- c("WE_sampbias_corrected", "CWE_sampbias_corrected", "richness_sampbias_corrected")

# projecting back to WGS84 for visualisation
merged_geo <- project(merged, "EPSG:4326")

# converting to data frame for plotting
merged_geo_df <- as.data.frame(merged_geo, xy = TRUE, na.rm = TRUE)
```

#### Calculating hotspots

```{r}
# Assigning hotspots based on percentile
merged_geo_df$WE_perc <- merged_geo_df$WE_sampbias_corrected > quantile(merged_geo_df$WE_sampbias_corrected, probs = 0.95)
merged_geo_df$CWE_perc <- merged_geo_df$CWE_sampbias_corrected > quantile(merged_geo_df$CWE_sampbias_corrected, probs = 0.95)
merged_geo_df$rich_perc <- merged_geo_df$richness_sampbias_corrected > quantile(merged_geo_df$richness_sampbias_corrected, probs = 0.95)
```

#### plotting

```{r}
ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_tile(data = merged_geo_df, aes(x=x, y=y, fill = WE_sampbias_corrected), col = NA) + 
  geom_tile(data = subset(merged_geo_df, WE_perc), aes(x=x, y=y), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_tile(data = merged_geo_df, aes(x=x, y=y, fill = CWE_sampbias_corrected), col = NA) + 
  geom_tile(data = subset(merged_geo_df, CWE_perc), aes(x=x, y=y), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_tile(data = merged_geo_df, aes(x=x, y=y, fill = richness_sampbias_corrected), col = NA) + 
  geom_tile(data = subset(merged_geo_df, rich_perc), aes(x=x, y=y), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")
```


## Short-range species

### Pre-processing

```{r}
# getting species with range size of 10000 m2 or less (<401 grid cells)
short_range_spp <- colnames(comm_merged[,which(colSums(comm_merged)<401)])

# Extract POLYGONs from GEOMETRYCOLLECTIONs
species_polys_clean_sr <- species_polys_clean |> 
  filter(species %in% short_range_spp)
  
# Combine into one large spatial dataframe
combinedShp_sr <- terra::vect(species_polys_clean_sr)

#projecting to Albers Equal Area projection (EPSG:9473 (GDA2020 / Australian Albers))
combinedShp_equalarea_sr <- project(combinedShp_sr, "EPSG:9473") 


```

### Calculate Community Matrix

Convert raw input distribution data to community at 0.05 decimal degrees
`trace = 1` is passed to `mean_dist()` which generates mean pairwise distance matrix from a set many pairwise distance matrices. Note: all matrices should be of the same dimension. `trace` "traces" the function; trace = 2 or higher will be more voluminous

```{r}
# community matrix for species with alpha hulls (at least 3 records)
comm.poly_sr <- phyloregion::polys2comm(dat = combinedShp_equalarea_sr, trace=1, res = 5000)

```

### Calculate weighted endemism 

```{r}
comm_merged_short_range_spp <- comm_merged[,which(colSums(comm_merged)<401)]

Endm.mygalomorph_sr <- phyloregion::weighted_endemism(comm_merged_short_range_spp)

# merging alpha hull- and point-based maps, ensuring that richness is summed in overlapping cells
comm_overlapping_sr <- merge(comm.poly_sr$map, comm.point$map, by = "grids", all.x = TRUE)
comm_overlapping_sr$richness <- ifelse(is.na(comm_overlapping_sr$richness.x), 0, comm_overlapping_sr$richness.x) + ifelse(is.na(comm_overlapping_sr$richness.y), 0, comm_overlapping_sr$richness.y)

non_overlapping_sr <- comm.point$map[which(!values(comm.point$map)[1]$grids %in% values(comm.poly_sr$map)[1]$grids),]

comm_merged_map_sr <- rbind(comm_overlapping_sr, non_overlapping_sr)

## Join endemism results back to spatial community data matrix
m1.poly_merged_sr <- merge(comm_merged_map_sr, data.frame(grids=names(Endm.mygalomorph_sr), WE=Endm.mygalomorph_sr), by="grids")

# Drop NA in WE
m1.poly_sr <- m1.poly_merged_sr[!is.na(m1.poly_merged_sr$WE),]

m1.poly_sr
```


### Calulate corrected weighted endemism

Weighted endemism tally per cell divided by the species richness of that cell

```{r}
m1.poly_sr$corrected_endemism <- m1.poly_sr$WE/m1.poly_sr$richness
```

### Assigning hotspots based on percentile

```{r}
m1.poly_sr$rich_perc <- m1.poly_sr$richness > quantile(m1.poly_sr$richness, probs = 0.95)
m1.poly_sr$WE_perc <- m1.poly_sr$WE > quantile(m1.poly_sr$WE, probs = 0.95)
m1.poly_sr$CWE_perc <- m1.poly_sr$corrected_endemism > quantile(m1.poly_sr$corrected_endemism, probs = 0.95)
```

### Create a endemism map

Convert to `sf` 

```{r}
crs(m1.poly_sr) <- "EPSG:9473"

# projecting back to WGS84 for visualisation
m1_sf_sr <- 
  sf::st_as_sf(m1.poly_sr) |> 
  sf::st_transform(4326)

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_sf(data = m1_sf_sr, aes(fill = WE), col = NA) + 
  geom_sf(data = subset(m1_sf_sr, WE_perc), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_sf(data = m1_sf_sr, aes(fill = corrected_endemism), col = NA) + 
  geom_sf(data = subset(m1_sf_sr, CWE_perc), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155), 
           ylim = c(-10, -45)) + 
  viridis::scale_fill_viridis(option = "G",direction = -1) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_sf(data = m1_sf_sr, aes(fill = richness), col = NA) + 
  geom_sf(data = subset(m1_sf_sr, rich_perc), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155), 
           ylim = c(-10, -45)) + 
  viridis::scale_fill_viridis(option = "G",direction = -1) + 
  theme_minimal() +
  theme(legend.position = "bottom")
```

### Correcting for sampling bias

#### converting biodiversity metrics to raster to perform corrections

```{r}
# testing as raster
m1.poly_sr_rast <- rast(m1.poly_sr, res = 5000)

# transferring from m1.poly attributes into a SpatRaster with multiple layers
m1.poly_sr_raster <- rast(lapply(names(m1.poly_sr)[c(6,8,9)], function(att) {
  rasterize(m1.poly_sr, m1.poly_sr_rast, field = att)
}))

# setting crs
crs(m1.poly_sr_raster) <- crs(sampling_rate_raster_ea)


# correcting biodiversity metrics based on (log+1) estimated sampling rate (dividing by sampling rate)
WE_sr_samp_bias <- terra::app(x = c(m1.poly_sr_raster$WE, tot_samp_bias_norm), 
                           fun = function(x){return(x[1]/x[2])})
CWE_sr_samp_bias <- terra::app(x = c(m1.poly_sr_raster$corrected_endemism, tot_samp_bias_norm), 
                                 fun = function(x){return(x[1]/x[2])})
richness_sr_samp_bias <- terra::app(x = c(m1.poly_sr_raster$richness, tot_samp_bias_norm), 
                                 fun = function(x){return(x[1]/x[2])})

merged_sr <- c(WE_sr_samp_bias, CWE_sr_samp_bias, richness_sr_samp_bias)
names(merged_sr) <- c("WE_sr_sampbias_corrected", "CWE_sr_sampbias_corrected", "richness_sr_sampbias_corrected")

# projecting back to WGS84 for visualisation
merged_sr_geo <- project(merged_sr, "EPSG:4326")

# converting to data frame for plotting
merged_geo_sr_df <- as.data.frame(merged_sr_geo, xy = TRUE, na.rm = TRUE)

# Assigning hotspots based on percentile
merged_geo_sr_df$WE_perc <- merged_geo_sr_df$WE_sr_sampbias_corrected > quantile(merged_geo_sr_df$WE_sr_sampbias_corrected, probs = 0.95)
merged_geo_sr_df$CWE_perc <- merged_geo_sr_df$CWE_sr_sampbias_corrected > quantile(merged_geo_sr_df$CWE_sr_sampbias_corrected, probs = 0.95)
merged_geo_sr_df$rich_perc <- merged_geo_sr_df$richness_sr_sampbias_corrected > quantile(merged_geo_sr_df$richness_sr_sampbias_corrected, probs = 0.95)
```

#### plotting

```{r}
ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_tile(data = merged_geo_sr_df, aes(x=x, y=y, fill = WE_sr_sampbias_corrected), col = NA) + 
  geom_tile(data = subset(merged_geo_sr_df, WE_perc), aes(x=x, y=y), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_tile(data = merged_geo_sr_df, aes(x=x, y=y, fill = CWE_sr_sampbias_corrected), col = NA) + 
  geom_tile(data = subset(merged_geo_sr_df, CWE_perc), aes(x=x, y=y), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_tile(data = merged_geo_sr_df, aes(x=x, y=y, fill = richness_sr_sampbias_corrected), col = NA) + 
  geom_tile(data = subset(merged_geo_sr_df, rich_perc), aes(x=x, y=y), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")
```

https://www.paulamoraga.com/book-spatial/spatial-autocorrelation.html#:~:text=Moran's%20I%20values%20significantly%20above,negative%20spatial%20autocorrelation%20or%20dispersion.

### Testing spatial autocorrelation

Moran's I - overall autocorrelation
```{r}
# extract the center of each polygon
coo <- terra::centroids(m1.poly)

coo <- coo |> sf::st_as_sf(crs = 4326)

# # variogram to assess spatial scale of dependence, i.e. range (search radius in following step)
# sf_proj <- st_transform(coo, crs = 3577)
# 
# variogram <- variogram(object = corrected_endemism~1, data = sf_proj)
# plot(variogram)
```

```{r}
# Search radius to include all neighboring polygon (0 - 20km)
S.dist  <-  dnearneigh(coo, 0, 20)

# S.dist <- readRDS("D:/USB/JNitschke/Invertebrates Australia/Cleaned_Mygalomorphae_dnearneigh500.rds")

```

```{r}
# #identify all neighboring polygons for each polygon in the dataset.(note: style = "W" means that weights are standardised by the number of neighbours (nb), ie. 1/nb, ensuring each observations influence is standardized regardless of number of neighbours)
# lw <- nb2listw(S.dist, style="W",zero.policy=T)
# 
# # Run the MC simulation
# RI_MI  <-  moran.mc(m1.poly$richness, lw, nsim=9999,zero.policy=T)
# WE_MI  <-  moran.mc(m1.poly$WE, lw, nsim=9999,zero.policy=T)
# CWE_MI  <-  moran.mc(m1.poly$corrected_endemism, lw, nsim=9999,zero.policy=T)
# 
# # saveRDS(RI_MI, "output/analysis/Cleaned_Mygalomorphae_RI_MI.rds")
# # saveRDS(WE_MI, "output/analysis/Cleaned_Mygalomorphae_WE_MI.rds")
# # saveRDS(CWE_MI, "output/analysis/Cleaned_Mygalomorphae_CWE_MI.rds")
```

Nelson and Boots (2008) have some info on analysis scale/neighbour distance
look into variograms for determining the spatial scale of dependence for setting a neighbour distance


Getis-Ord's G* - to identify significant clusters
```{r}
tmap_mode("plot")

#identify all neighboring polygons for each polygon in the dataset (including self)
lw_self <- nb2listw(include.self(S.dist), style="W",zero.policy=T) 

# calculate Getis-Ord's G*
RI_local_G <- localG(m1.poly$WE, lw_self, alternative = "greater")

RI_local_G_att <- attributes(RI_local_G)

m1_sf$gI <- RI_local_G_att$internals[, "G*i"] # Getis-Ord G
m1_sf$gZ <- RI_local_G_att$internals[, "Z(G*i)"] # z-scores
m1_sf$gp <- RI_local_G_att$internals[, "Pr(z > E(G*i))"] # p-values corresponding to alternative

#designating points to quadrants based on Getis-Ord's G* and corresponding p-values
m1_sf$quadrant_g <- NA
# high-high
m1_sf[m1_sf$gI > 0 & (!is.na(m1_sf$gp) & m1_sf$gp <= 0.0001), "quadrant_g"] <- 1
# low-low
#m1_sf[m1_sf$gI < 0 & (!is.na(m1_sf$gp) & m1_sf$gp <= 0.0001), "quadrant_g"] <- 2
# non-significant
m1_sf[(!is.na(m1_sf$gp) & m1_sf$gp > 0.0001), "quadrant_g"] <- 3

#mapping clusters
m1_sf$cluster_label <- factor(m1_sf$quadrant_g,
  levels = c(1, 3),
  labels = c("High-High", "Non-significant")
)

tm_500 <- tm_shape(m1_sf) + tm_fill(fill = "cluster_label",
                          fill.scale = tm_scale(values =  c("red", "white")),
                          fill_alpha = 0.5,
                          fill.legend = tm_legend(title = "Clusters",
                                                  text.size = 1),
                          col = "grey") +
  tm_borders(col = "cluster_label",
                          col.scale = tm_scale(values = c("red", "grey")),
                          col_alpha = 0.5,
                          col.legend = tm_legend(show = FALSE)) +
tm_layout(frame = FALSE) +
tm_layout(legend.outside = TRUE)

tm_500
```

## EXPERT DATA ONLY

```{r}
# Extract POLYGONs from GEOMETRYCOLLECTIONs
species_polys_expert_clean <- species_polys_points_expert  |>
  st_collection_extract() |>
  group_by(species) |>
  summarise(geometry = st_union(conr_ahull_sf))
  
# Combine into one large spatial dataframe
combinedShp_ex <- terra::vect(species_polys_expert_clean)

#projecting to Albers Equal Area projection (EPSG:9473 (GDA2020 / Australian Albers))
combinedShp_ex_equalarea <- project(combinedShp_ex, "EPSG:9473") 


# now for point-only species
species_points_ex_clean <- species_polys_points_expert |>
  filter(st_geometry_type(conr_ahull_sf) %in% c("POINT", "MULTIPOINT"))

## seems like phyloregion::polys2comm() also works for point data if in spatvector format
myg_spiders_cleaned_points_ex <- myg_spiders_expert |>
  filter(scientificName %in% species_points_ex_clean$species) |>
  dplyr::select(species, decimalLongitude, decimalLatitude) |>
  sf::st_as_sf(coords = c("decimalLongitude", "decimalLatitude"), crs = "EPSG:4326") |>
  sf::st_transform(crs = "EPSG:9473") #projecting to Albers Equal Area projection (EPSG:9473 (GDA2020 / Australian Albers))

combinedShp_ex_points_equalarea <- terra::vect(myg_spiders_cleaned_points_ex)

```

### Calculate Community Matrix

Convert raw input distribution data to community at 0.05 decimal degrees
`trace = 1` is passed to `mean_dist()` which generates mean pairwise distance matrix from a set many pairwise distance matrices. Note: all matrices should be of the same dimension. `trace` "traces" the function; trace = 2 or higher will be more voluminous

```{r}
# community matrix for species with alpha hulls (at least 3 records)
comm.poly_ex <- phyloregion::polys2comm(dat = combinedShp_ex_equalarea, trace=1, res = 5000)
str(comm.poly_ex)
plot(comm.poly_ex$map)

# community matrix for species without alpha hulls (<3 records)
comm.point_ex <- phyloregion::polys2comm(dat = combinedShp_ex_points_equalarea, res = 5000)
plot(comm.point_ex$map)


# combining
all_species_ex <- union(colnames(comm.poly_ex$comm_dat), colnames(comm.point_ex$comm_dat))

missing_in_poly_ex <- setdiff(all_species_ex, colnames(comm.poly_ex$comm_dat))
missing_in_poly_ex_matrix <- sparseMatrix(i = numeric(0), j = numeric(0), x = numeric(0),
                                   dims = c(nrow(comm.poly_ex$comm_dat), 
                                            length(missing_in_poly_ex)))
colnames(missing_in_poly_ex_matrix) <- missing_in_poly_ex


missing_in_point_ex <- setdiff(all_species_ex, colnames(comm.point_ex$comm_dat))
missing_in_point_ex_matrix <- sparseMatrix(i = numeric(0), j = numeric(0), x = numeric(0),
                                   dims = c(nrow(comm.point_ex$comm_dat), 
                                            length(missing_in_point_ex)))
colnames(missing_in_point_ex_matrix) <- missing_in_point_ex


comm.poly_all_spp_ex  <- cbind(comm.poly_ex$comm_dat, missing_in_poly_ex_matrix)
comm.point_all_spp_ex  <- cbind(comm.point_ex$comm_dat, missing_in_point_ex_matrix)

# Expand both matrices to have all grid cells
all_grids_ex <- union(rownames(comm.poly_all_spp_ex), rownames(comm.point_all_spp_ex))

expand_rows <- function(mat, all_grids) {
  missing <- setdiff(all_grids, rownames(mat))
  if (length(missing) > 0) {
    mat <- rbind(mat, Matrix(0, nrow=length(missing), ncol=ncol(mat),
                             dimnames=list(missing, colnames(mat))))
  }
  mat[all_grids, , drop=FALSE]  # reorder rows
}

comm.poly_all_spp_all_grids_ex <- expand_rows(comm.poly_all_spp_ex, all_grids_ex)
comm.point_all_spp_all_grids_ex <- expand_rows(comm.point_all_spp_ex, all_grids_ex)

# matching order of columns prior to combining matrices
species_order_ex <- colnames(comm.poly_all_spp_all_grids_ex)
comm.point_all_spp_all_grids_ex <- comm.point_all_spp_all_grids_ex[,species_order_ex, drop = FALSE]

# Combine (sum values if grids overlap)
comm_merged_ex <- comm.poly_all_spp_all_grids_ex + comm.point_all_spp_all_grids_ex
```

### Calculate weighted endemism 

```{r}
Endm.mygalomorph_ex <- phyloregion::weighted_endemism(comm_merged_ex)

# merging alpha hull- and point-based maps, ensuring that richness is summed in overlapping cells
comm_overlapping_ex <- merge(comm.poly_ex$map, comm.point_ex$map, by = "grids", all.x = TRUE)
comm_overlapping_ex$richness <- ifelse(is.na(comm_overlapping_ex$richness.x), 0, comm_overlapping_ex$richness.x) + ifelse(is.na(comm_overlapping_ex$richness.y), 0, comm_overlapping_ex$richness.y)

non_overlapping_ex <- comm.point_ex$map[which(!values(comm.point_ex$map)[1]$grids %in% values(comm.poly_ex$map)[1]$grids),]

comm_merged_map_ex <- rbind(comm_overlapping_ex, non_overlapping_ex)

## Join results back to spatial community data matrix
m1.poly_merged_ex <- merge(comm_merged_map_ex, data.frame(grids=names(Endm.mygalomorph_ex), WE=Endm.mygalomorph_ex), by="grids")

# Drop NA in WE
m1.poly_ex <- m1.poly_merged_ex[!is.na(m1.poly_merged_ex$WE),]

m1.poly_ex
```


### Calulate corrected weighted endemism

Weighted endemism tally per cell divided by the species richness of that cell

```{r}
m1.poly_ex$corrected_endemism <- m1.poly_ex$WE/m1.poly_ex$richness
```

### Assigning hotspots based on percentile

```{r}
m1.poly_ex$rich_perc <- m1.poly_ex$richness > quantile(m1.poly_ex$richness, probs = 0.95)
m1.poly_ex$WE_perc <- m1.poly_ex$WE > quantile(m1.poly_ex$WE, probs = 0.95)
m1.poly_ex$CWE_perc <- m1.poly_ex$corrected_endemism > quantile(m1.poly_ex$corrected_endemism, probs = 0.95)
```

### Create a endemism map

Convert to `sf` 

```{r}
crs(m1.poly_ex) <- "EPSG:9473"

# projecting back to WGS84 for visualisation
m1_sf_ex <- 
  sf::st_as_sf(m1.poly_ex) |> 
  sf::st_transform(4326)

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_sf(data = m1_sf_ex, aes(fill = WE), col = NA) + 
  geom_sf(data = subset(m1_sf_ex, WE_perc), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155), 
           ylim = c(-10, -45)) + 
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_sf(data = m1_sf_ex, aes(fill = corrected_endemism), col = NA) + 
  geom_sf(data = subset(m1_sf_ex, CWE_perc), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155), 
           ylim = c(-10, -45)) + 
  viridis::scale_fill_viridis(option = "G",direction = -1) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_sf(data = m1_sf_ex, aes(fill = richness), col = NA) + 
  geom_sf(data = subset(m1_sf_ex, rich_perc), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155), 
           ylim = c(-10, -45)) + 
  viridis::scale_fill_viridis(option = "G",direction = -1) + 
  theme_minimal() +
  theme(legend.position = "bottom")
```

### Correcting for sampling bias

#### converting biodiversity metrics to raster to perform corrections

```{r}
# testing as raster
m1.poly_ex_rast <- rast(m1.poly_ex, res = 5000)

# transferring from m1.poly attributes into a SpatRaster with multiple layers
m1.poly_ex_raster <- rast(lapply(names(m1.poly_ex)[c(6,8,9)], function(att) {
  rasterize(m1.poly_ex, m1.poly_ex_rast, field = att)
}))

# setting crs
crs(m1.poly_ex_raster) <- crs(sampling_rate_raster_ea)


# correcting biodiversity metrics based on (log+1) estimated sampling rate (dividing by sampling rate)
WE_ex_samp_bias <- terra::app(x = c(m1.poly_ex_raster$WE, tot_samp_bias_norm), 
                           fun = function(x){return(x[1]/x[2])})
CWE_ex_samp_bias <- terra::app(x = c(m1.poly_ex_raster$corrected_endemism, tot_samp_bias_norm), 
                                 fun = function(x){return(x[1]/x[2])})
richness_ex_samp_bias <- terra::app(x = c(m1.poly_ex_raster$richness, tot_samp_bias_norm), 
                                 fun = function(x){return(x[1]/x[2])})

merged_ex <- c(WE_ex_samp_bias, CWE_ex_samp_bias, richness_ex_samp_bias)
names(merged_ex) <- c("WE_ex_sampbias_corrected", "CWE_ex_sampbias_corrected", "richness_ex_sampbias_corrected")

# projecting back to WGS84 for visualisation
merged_ex_geo <- project(merged_ex, "EPSG:4326")

# converting to data frame for plotting
merged_geo_ex_df <- as.data.frame(merged_ex_geo, xy = TRUE, na.rm = TRUE)

# Assigning hotspots based on percentile
merged_geo_ex_df$WE_perc <- merged_geo_ex_df$WE_ex_sampbias_corrected > quantile(merged_geo_ex_df$WE_ex_sampbias_corrected, probs = 0.95)
merged_geo_ex_df$CWE_perc <- merged_geo_ex_df$CWE_ex_sampbias_corrected > quantile(merged_geo_ex_df$CWE_ex_sampbias_corrected, probs = 0.95)
merged_geo_ex_df$rich_perc <- merged_geo_ex_df$richness_ex_sampbias_corrected > quantile(merged_geo_ex_df$richness_ex_sampbias_corrected, probs = 0.95)
```

#### plotting

```{r}
ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_tile(data = merged_geo_ex_df, aes(x=x, y=y, fill = WE_ex_sampbias_corrected), col = NA) + 
  geom_tile(data = subset(merged_geo_ex_df, WE_perc), aes(x=x, y=y), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_tile(data = merged_geo_ex_df, aes(x=x, y=y, fill = CWE_ex_sampbias_corrected), col = NA) + 
  geom_tile(data = subset(merged_geo_ex_df, CWE_perc), aes(x=x, y=y), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_tile(data = merged_geo_ex_df, aes(x=x, y=y, fill = richness_ex_sampbias_corrected), col = NA) + 
  geom_tile(data = subset(merged_geo_ex_df, rich_perc), aes(x=x, y=y), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")
```

https://www.paulamoraga.com/book-spatial/spatial-autocorrelation.html#:~:text=Moran's%20I%20values%20significantly%20above,negative%20spatial%20autocorrelation%20or%20dispersion.

### Testing spatial autocorrelation

Moran's I - overall autocorrelation
```{r}
# extract the center of each polygon
coo_ex <- terra::centroids(m1.poly_ex)

coo_ex <- coo_ex |> sf::st_as_sf(crs = 4326)

# Search radius to include all neighboring polygon (0 - 200km)
S.dist_ex  <-  dnearneigh(coo_ex, 0, 200)  

#identify all neighboring polygons for each polygon in the dataset.
lw_ex <- nb2listw(S.dist_ex, style="W",zero.policy=T) 

# Run the MC simulation
RI_MI_ex  <-  moran.mc(m1.poly_ex$richness, lw, nsim=9999,zero.policy=T)
WE_MI_ex  <-  moran.mc(m1.poly_ex$WE, lw, nsim=9999,zero.policy=T)
CWE_MI_ex  <-  moran.mc(m1.poly_ex$corrected_endemism, lw, nsim=9999,zero.policy=T)

# saveRDS(RI_MI_ex, "output/analysis/Cleaned_Mygalomorphae_RI_MI_expert.rds")
# saveRDS(WE_MI_ex, "output/analysis/Cleaned_Mygalomorphae_WE_MI_expert.rds")
# saveRDS(CWE_MI_ex, "output/analysis/Cleaned_Mygalomorphae_CWE_MI_expert.rds")
```

Getis-Ord's G* - to identify significant clusters
```{r}
tmap_mode("plot")

#identify all neighboring polygons for each polygon in the dataset (including self)
lw_self_ex <- nb2listw(include.self(S.dist_ex), style="W",zero.policy=T) 

# calculate Getis-Ord's G*
RI_local_G_ex <- localG(m1.poly_ex$WE, lw_self_ex, alternative = "greater")

RI_local_G_ex_att <- attributes(RI_local_G_ex)

m1_sf_ex$gI <- RI_local_G_ex_att$internals[, "G*i"] # Getis-Ord G
m1_sf_ex$gZ <- RI_local_G_ex_att$internals[, "Z(G*i)"] # z-scores
m1_sf_ex$gp <- RI_local_G_ex_att$internals[, "Pr(z > E(G*i))"] # p-values corresponding to alternative

#designating points to quadrants based on Getis-Ord's G* and corresponding p-values
m1_sf_ex$quadrant_g <- NA
# high-high
m1_sf_ex[m1_sf_ex$gI > 0 & (!is.na(m1_sf_ex$gp) & m1_sf_ex$gp <= 0.0001), "quadrant_g"] <- 1
# low-low
#m1_sf_ex[m1_sf_ex$gI < 0 & (!is.na(m1_sf_ex$gp) & m1_sf_ex$gp <= 0.0001), "quadrant_g"] <- 2
# non-significant
m1_sf_ex[(!is.na(m1_sf_ex$gp) & m1_sf_ex$gp > 0.0001), "quadrant_g"] <- 3

#mapping clusters
m1_sf_ex$cluster_label <- factor(m1_sf_ex$quadrant_g,
  levels = c(1, 3),
  labels = c("High-High", "Non-significant")
)

tm_shape(m1_sf_ex) + tm_fill(fill = "cluster_label",
                          fill.scale = tm_scale(values =  c("red", "white")),
                          fill_alpha = 0.5,
                          fill.legend = tm_legend(title = "Clusters",
                                                  text.size = 1),
                          col = "grey") +
  tm_borders(col = "cluster_label",
                          col.scale = tm_scale(values = c("red", "grey")),
                          col_alpha = 0.5,
                          col.legend = tm_legend(show = FALSE)) +
tm_layout(frame = FALSE) +
tm_layout(legend.outside = TRUE)
```

## Short-range species

### Pre-processing

```{r}
# getting species with range size of 10000 m2 or less (<401 grid cells)
short_range_spp_ex <- colnames(comm_merged_ex[,which(colSums(comm_merged_ex)<401)])

# Extract POLYGONs from GEOMETRYCOLLECTIONs
species_polys_clean_sr_ex <- species_polys_expert_clean |> 
  filter(species %in% short_range_spp_ex)
  
# Combine into one large spatial dataframe
combinedShp_sr_ex <- terra::vect(species_polys_clean_sr_ex)

#projecting to Albers Equal Area projection (EPSG:9473 (GDA2020 / Australian Albers))
combinedShp_equalarea_sr_ex <- project(combinedShp_sr_ex, "EPSG:9473") 


```

### Calculate Community Matrix

Convert raw input distribution data to community at 0.05 decimal degrees
`trace = 1` is passed to `mean_dist()` which generates mean pairwise distance matrix from a set many pairwise distance matrices. Note: all matrices should be of the same dimension. `trace` "traces" the function; trace = 2 or higher will be more voluminous

```{r}
# community matrix for species with alpha hulls (at least 3 records)
comm.poly_sr_ex <- phyloregion::polys2comm(dat = combinedShp_equalarea_sr_ex, trace=1, res = 5000)

```

### Calculate weighted endemism 

```{r}
comm_merged_short_range_spp_ex <- comm_merged[,which(colSums(comm_merged_ex)<401)]

Endm.mygalomorph_sr_ex <- phyloregion::weighted_endemism(comm_merged_short_range_spp_ex)

# merging alpha hull- and point-based maps, ensuring that richness is summed in overlapping cells
comm_overlapping_sr_ex <- merge(comm.poly_sr_ex$map, comm.point$map, by = "grids", all.x = TRUE)
comm_overlapping_sr_ex$richness <- ifelse(is.na(comm_overlapping_sr_ex$richness.x), 0, comm_overlapping_sr_ex$richness.x) + ifelse(is.na(comm_overlapping_sr_ex$richness.y), 0, comm_overlapping_sr_ex$richness.y)

non_overlapping_sr_ex <- comm.point$map[which(!values(comm.point$map)[1]$grids %in% values(comm.poly_sr_ex$map)[1]$grids),]

comm_merged_map_sr_ex <- rbind(comm_overlapping_sr_ex, non_overlapping_sr_ex)

## Join endemism results back to spatial community data matrix
m1.poly_merged_sr_ex <- merge(comm_merged_map_sr_ex, data.frame(grids=names(Endm.mygalomorph_sr_ex), WE=Endm.mygalomorph_sr_ex), by="grids")

# Drop NA in WE
m1.poly_sr_ex <- m1.poly_merged_sr_ex[!is.na(m1.poly_merged_sr_ex$WE),]

m1.poly_sr_ex
```


### Calulate corrected weighted endemism

Weighted endemism tally per cell divided by the species richness of that cell

```{r}
m1.poly_sr_ex$corrected_endemism <- m1.poly_sr_ex$WE/m1.poly_sr_ex$richness
```

### Assigning hotspots based on percentile

```{r}
m1.poly_sr_ex$rich_perc <- m1.poly_sr_ex$richness > quantile(m1.poly_sr_ex$richness, probs = 0.95)
m1.poly_sr_ex$WE_perc <- m1.poly_sr_ex$WE > quantile(m1.poly_sr_ex$WE, probs = 0.95)
m1.poly_sr_ex$CWE_perc <- m1.poly_sr_ex$corrected_endemism > quantile(m1.poly_sr_ex$corrected_endemism, probs = 0.95)
```

### Create a endemism map

Convert to `sf` 

```{r}
crs(m1.poly_sr_ex) <- "EPSG:9473"

# projecting back to WGS84 for visualisation
m1_sf_sr_ex <- 
  sf::st_as_sf(m1.poly_sr_ex) |> 
  sf::st_transform(4326)

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_sf(data = m1_sf_sr_ex, aes(fill = WE), col = NA) + 
  geom_sf(data = subset(m1_sf_sr_ex, WE_perc), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_sf(data = m1_sf_sr_ex, aes(fill = corrected_endemism), col = NA) + 
  geom_sf(data = subset(m1_sf_sr_ex, CWE_perc), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155), 
           ylim = c(-10, -45)) + 
  viridis::scale_fill_viridis(option = "G",direction = -1) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_sf(data = m1_sf_sr_ex, aes(fill = richness), col = NA) + 
  geom_sf(data = subset(m1_sf_sr_ex, rich_perc), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155), 
           ylim = c(-10, -45)) + 
  viridis::scale_fill_viridis(option = "G",direction = -1) + 
  theme_minimal() +
  theme(legend.position = "bottom")
```

### Correcting for sampling bias

#### converting biodiversity metrics to raster to perform corrections

```{r}
# testing as raster
m1.poly_sr_ex_rast <- rast(m1.poly_sr_ex, res = 5000)

# transferring from m1.poly attributes into a SpatRaster with multiple layers
m1.poly_sr_ex_raster <- rast(lapply(names(m1.poly_sr_ex)[c(6,8,9)], function(att) {
  rasterize(m1.poly_sr_ex, m1.poly_sr_ex_rast, field = att)
}))

# setting crs
crs(m1.poly_sr_ex_raster) <- crs(sampling_rate_raster_ea)


# correcting biodiversity metrics based on (log+1) estimated sampling rate (dividing by sampling rate)
WE_sr_ex_samp_bias <- terra::app(x = c(m1.poly_sr_ex_raster$WE, tot_samp_bias_norm), 
                           fun = function(x){return(x[1]/x[2])})
CWE_sr_ex_samp_bias <- terra::app(x = c(m1.poly_sr_ex_raster$corrected_endemism, tot_samp_bias_norm), 
                                 fun = function(x){return(x[1]/x[2])})
richness_sr_ex_samp_bias <- terra::app(x = c(m1.poly_sr_ex_raster$richness, tot_samp_bias_norm), 
                                 fun = function(x){return(x[1]/x[2])})

merged_sr_ex <- c(WE_sr_ex_samp_bias, CWE_sr_ex_samp_bias, richness_sr_ex_samp_bias)
names(merged_sr_ex) <- c("WE_sr_ex_sampbias_corrected", "CWE_sr_ex_sampbias_corrected", "richness_sr_ex_sampbias_corrected")

# projecting back to WGS84 for visualisation
merged_sr_ex_geo <- project(merged_sr_ex, "EPSG:4326")

# converting to data frame for plotting
merged_geo_sr_ex_df <- as.data.frame(merged_sr_ex_geo, xy = TRUE, na.rm = TRUE)

# Assigning hotspots based on percentile
merged_geo_sr_ex_df$WE_perc <- merged_geo_sr_ex_df$WE_sr_ex_sampbias_corrected > quantile(merged_geo_sr_ex_df$WE_sr_ex_sampbias_corrected, probs = 0.95)
merged_geo_sr_ex_df$CWE_perc <- merged_geo_sr_ex_df$CWE_sr_ex_sampbias_corrected > quantile(merged_geo_sr_ex_df$CWE_sr_ex_sampbias_corrected, probs = 0.95)
merged_geo_sr_ex_df$rich_perc <- merged_geo_sr_ex_df$richness_sr_ex_sampbias_corrected > quantile(merged_geo_sr_ex_df$richness_sr_ex_sampbias_corrected, probs = 0.95)
```

#### plotting

```{r}
ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_tile(data = merged_geo_sr_ex_df, aes(x=x, y=y, fill = WE_sr_ex_sampbias_corrected), col = NA) + 
  geom_tile(data = subset(merged_geo_sr_ex_df, WE_perc), aes(x=x, y=y), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_tile(data = merged_geo_sr_ex_df, aes(x=x, y=y, fill = CWE_sr_ex_sampbias_corrected), col = NA) + 
  geom_tile(data = subset(merged_geo_sr_ex_df, CWE_perc), aes(x=x, y=y), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot() +
  geom_sf(data = ozmap_states, fill = "white") + 
  geom_tile(data = merged_geo_sr_ex_df, aes(x=x, y=y, fill = richness_sr_ex_sampbias_corrected), col = NA) + 
  geom_tile(data = subset(merged_geo_sr_ex_df, rich_perc), aes(x=x, y=y), fill = "red", col = NA) +
  geom_sf(data = ozmap_states, fill = NA, colour = "black") + 
  coord_sf(xlim = c(110, 155),
          ylim = c(-10, -45)) +
  viridis::scale_fill_viridis(option = "G",direction = -1#, values = c(0,0.01,0.1,1)
                              ) + 
  theme_minimal() +
  theme(legend.position = "bottom")
```



```{r, echo=FALSE}
# Exploring discrepancies between old and new data pulls

exp_old <- read_parquet(here("output/data/cleaned_expert_recordscleaned_Mygalomorphae_withassertions_2024-03-13_ALA"))
exp_new <- read_parquet(here("output/data/cleaned_expert_recordsMygalomorphae_withassertions_2025-08-14_ALA.parquet"))

old_not_new <- exp_old[which(!exp_old$recordID %in% exp_new$recordID),]

new_coarse <- read_parquet(here("data/galah/Mygalomorphae_withassertions_2025-08-14_ALA.parquet"))

## alpha hulls
filtered <- species_polys |> filter(species == "Selenocosmia stirlingi")
filtered2 <- myg_spiders_cleaned |> filter(species == "Selenocosmia stirlingi")

base_map  + 
  # geom_sf(data = filtered, 
  #         aes(geometry = x, fill = species),
  #         #fill = species,
  #         alpha = 0.5,
  #         colour = "darkgrey") + 
  # geom_sf_text(data = filtered, aes(label = species), size = 1) +
  geom_point(data = exp_old, aes(x = decimalLongitude, y = decimalLatitude)) +
  geom_point(data = exp_new, aes(x = decimalLongitude, y = decimalLatitude), fill = "red", col = "red") +
  geom_point(data = old_not_new, aes(x = decimalLongitude, y = decimalLatitude), fill = "blue", col = "blue") +
  geom_sf(data = aus, fill = NA, colour = "black") + 
  coord_sf(c(110, 155)) +
  theme_minimal() +
  theme(legend.position = "none")

# ## Community Matrix
# #|   #| fig-cap: 
# #|   - "Community matrix of Mygalomorphae spiders from our cleaned dataset"
# comm.poly <- phyloregion::polys2comm(dat = combinedShp , trace=1, res = 0.05)
# plot(comm.poly$map)
```